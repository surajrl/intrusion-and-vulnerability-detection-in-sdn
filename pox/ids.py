from pox.core import core
import pox.openflow.libopenflow_01 as of
import pox.log.color
from pox.lib.recoco import Timer
import fcntl
import csv

log = core.getLogger()


class IDS(object):
    def __init__(self, connection, input_filepath):
        # Keep track of the connection to the switch so that we can send it messages.
        self.connection = connection
        # Bind our event listeners to the switch.
        self.connection.addListeners(self)

        # This table maps (switch,MAC-addr) pairs to the port on 'switch' at
        # which we last saw a packet *from* 'MAC-addr'.
        # (In this case, we use a Connection object for the switch.)
        self.table = {}

        self.flow_features_file = open(input_filepath, "r+")

        Timer(timeToWake=10, callback=self.predict, recurring=True)

    def predict(self):
        # Read file containing flow features
        fcntl.flock(self.flow_features_file, fcntl.LOCK_EX)
        flows = list(csv.reader(self.flow_features_file))
        for flow in flows:
            print(flow)
        fcntl.flock(self.flow_features_file, fcntl.LOCK_UN)

        # Predict on them

        return

    # Handle messages the switch has sent us because it has no
    # matching rule.
    def _handle_PacketIn(self, event):
        packet = event.parsed

        # Learn the source
        self.table[(event.connection, packet.src)] = event.port

        dst_port = self.table.get((event.connection, packet.dst))

        if dst_port is None:
            # We don't know where the destination is yet. So, we'll just
            # send the packet out all ports (except the one it came in on!)
            # and hope the destination is out there somewhere. :)
            msg = of.ofp_packet_out(data=event.ofp)
            msg.actions.append(of.ofp_action_output(port=of.OFPP_FLOOD))
            self.connection.send(msg)
        else:
            # Since we know the switch ports for both the source and dest
            # MACs, we can install rules for both directions.
            msg = of.ofp_flow_mod()
            msg.match.dl_dst = packet.src
            msg.match.dl_src = packet.dst
            msg.actions.append(of.ofp_action_output(port=event.port))
            self.connection.send(msg)

            # This is the packet that just came in -- we want to
            # install the rule and also resend the packet.
            msg = of.ofp_flow_mod()
            msg.data = event.ofp  # Forward the incoming packet
            msg.match.dl_src = packet.src
            msg.match.dl_dst = packet.dst
            msg.actions.append(of.ofp_action_output(port=dst_port))
            self.connection.send(msg)

            log.debug("Installing %s <-> %s" % (packet.src, packet.dst))


def launch():
    # Logger configuration.
    pox.log.color.launch()
    pox.log.launch(
        format="[@@@bold%(levelname)s@@@reset][@@@bold%(asctime)s@@@reset][@@@bold%(filename)s@@@reset]: @@@bold%(message)s@@@normal"
    )

    def start_switch_connection(event):
        log.info("Controlling %s" % (event.connection,))
        IDS(event.connection)

    # Start connection of the controller with the switch.
    core.openflow.addListenerByName("ConnectionUp", start_switch_connection)
