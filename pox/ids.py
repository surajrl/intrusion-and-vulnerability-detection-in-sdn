from pox.core import core
import pox.openflow.libopenflow_01 as of
import pox.log.color
from pox.lib.recoco import Timer
import fcntl
import pandas as pd
import os
import pickle
import numpy as np

log = core.getLogger()


class IDS(object):
    def __init__(self, connection, input_dir):
        # Keep track of the connection to the switch so that we can send it messages.
        self.connection = connection
        # Bind our event listeners to the switch.
        self.connection.addListeners(self)

        # This table maps (switch,MAC-addr) pairs to the port on 'switch' at
        # which we last saw a packet *from* 'MAC-addr'.
        # (In this case, we use a Connection object for the switch.)
        self.table = {}

        self.input_dir = input_dir

        root_path = "/home/suraj/intrusion-and-vulnerability-detection-in-sdn/ml/saved/"
        model_name = "dos_goldeneye"

        # Load the trained classifier.
        self.clf = pickle.load(open(root_path + f"/{model_name}_model.pkl", "rb"))
        # Load the normalization scaler.
        self.scaler = pickle.load(open(root_path + f"/{model_name}_scaler.pkl", "rb"))

        Timer(timeToWake=10, callback=self.predict, recurring=True)

    def predict(self):
        print("Analyzing flows ...")

        class_labels = ["benign", "dos_goldeneye"]

        for file in os.listdir(self.input_dir):
            filepath = os.path.join(self.input_dir, file)

            try:
                flows_df = pd.read_csv(filepath, skipinitialspace=True)
            except pd.errors.EmptyDataError:
                print("No flows to analyze.\n")
                return

            unlabelled_flows_df = flows_df[flows_df["label"] == "unlabelled"]
            if unlabelled_flows_df.empty:
                print("No flows to analyze.\n")
                return

            # TODO: Could predict on the entire flows instead of reading one-by-one ??
            for index, unlabelled_flow in unlabelled_flows_df.iterrows():
                features_normalized = self.scaler.transform(
                    np.array(unlabelled_flow.drop(["label", "id"]).tolist()).reshape(
                        1, -1
                    )
                )
                prediction = self.clf.predict(features_normalized)[0]
                print(f"Prediction {unlabelled_flow['id']}: {class_labels[prediction]}")
                flows_df.at[index, "label"] = class_labels[prediction]

            # Save changes to file.
            with open(filepath, "a") as file:
                fcntl.flock(file, fcntl.LOCK_EX)  # Acquire an exclusive lock.
                flows_df.to_csv(filepath, index=False)
                fcntl.flock(file, fcntl.LOCK_UN)  # Release the lock.

    # Handle messages the switch has sent us because it has no matching rule.
    def _handle_PacketIn(self, event):
        packet = event.parsed

        # Learn the source
        self.table[(event.connection, packet.src)] = event.port

        dst_port = self.table.get((event.connection, packet.dst))

        if dst_port is None:
            # We don't know where the destination is yet. So, we'll just
            # send the packet out all ports (except the one it came in on!)
            # and hope the destination is out there somewhere. :)
            msg = of.ofp_packet_out(data=event.ofp)
            msg.actions.append(of.ofp_action_output(port=of.OFPP_FLOOD))
            self.connection.send(msg)
        else:
            # Since we know the switch ports for both the source and dest
            # MACs, we can install rules for both directions.
            msg = of.ofp_flow_mod()
            msg.match.dl_dst = packet.src
            msg.match.dl_src = packet.dst
            msg.actions.append(of.ofp_action_output(port=event.port))
            self.connection.send(msg)

            # This is the packet that just came in -- we want to
            # install the rule and also resend the packet.
            msg = of.ofp_flow_mod()
            msg.data = event.ofp  # Forward the incoming packet
            msg.match.dl_src = packet.src
            msg.match.dl_dst = packet.dst
            msg.actions.append(of.ofp_action_output(port=dst_port))
            self.connection.send(msg)

            log.debug("Installing %s <-> %s" % (packet.src, packet.dst))


def launch():
    # Logger configuration.
    pox.log.color.launch()
    pox.log.launch(
        format="[@@@bold%(levelname)s@@@reset][@@@bold%(asctime)s@@@reset][@@@bold%(filename)s@@@reset]: @@@bold%(message)s@@@normal"
    )

    def start_switch_connection(event):
        log.info("Controlling %s" % (event.connection,))
        IDS(
            event.connection,
            "/home/suraj/intrusion-and-vulnerability-detection-in-sdn/flow_extraction/",
        )

    # Start connection of the controller with the switch.
    core.openflow.addListenerByName("ConnectionUp", start_switch_connection)
