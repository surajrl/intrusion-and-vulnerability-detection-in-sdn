from pox.core import core
import pox.openflow.libopenflow_01 as of
import pox.log.color

import pandas as pd
import pickle
import numpy as np
import threading
from nfstream import NFStreamer, NFPlugin

log = core.getLogger()


class ModelPrediction(NFPlugin):
    def on_init(self, packet, flow):
        flow.udps.prediction = 0
        flow.udps.features = np.empty(shape=(0,))

    def on_expire(self, flow):
        to_predict = np.array(
            [
                flow.bidirectional_duration_ms,
                flow.bidirectional_packets,
                flow.bidirectional_bytes,
                flow.src2dst_duration_ms,
                flow.src2dst_packets,
                flow.src2dst_bytes,
                flow.dst2src_duration_ms,
                flow.dst2src_packets,
                flow.dst2src_bytes,
                flow.bidirectional_min_ps,
                flow.bidirectional_mean_ps,
                flow.bidirectional_stddev_ps,
                flow.bidirectional_max_ps,
                flow.src2dst_min_ps,
                flow.src2dst_mean_ps,
                flow.src2dst_stddev_ps,
                flow.src2dst_max_ps,
                flow.dst2src_min_ps,
                flow.dst2src_mean_ps,
                flow.dst2src_stddev_ps,
                flow.dst2src_max_ps,
                flow.bidirectional_min_piat_ms,
                flow.bidirectional_mean_piat_ms,
                flow.bidirectional_stddev_piat_ms,
                flow.bidirectional_max_piat_ms,
                flow.src2dst_min_piat_ms,
                flow.src2dst_mean_piat_ms,
                flow.src2dst_stddev_piat_ms,
                flow.src2dst_max_piat_ms,
                flow.dst2src_min_piat_ms,
                flow.dst2src_mean_piat_ms,
                flow.dst2src_stddev_piat_ms,
                flow.dst2src_max_piat_ms,
                flow.bidirectional_syn_packets,
                flow.bidirectional_cwr_packets,
                flow.bidirectional_ece_packets,
                flow.bidirectional_urg_packets,
                flow.bidirectional_ack_packets,
                flow.bidirectional_psh_packets,
                flow.bidirectional_rst_packets,
                flow.bidirectional_fin_packets,
                flow.src2dst_syn_packets,
                flow.src2dst_cwr_packets,
                flow.src2dst_ece_packets,
                flow.src2dst_urg_packets,
                flow.src2dst_ack_packets,
                flow.src2dst_psh_packets,
                flow.src2dst_rst_packets,
                flow.src2dst_fin_packets,
                flow.dst2src_syn_packets,
                flow.dst2src_cwr_packets,
                flow.dst2src_ece_packets,
                flow.dst2src_urg_packets,
                flow.dst2src_ack_packets,
                flow.dst2src_psh_packets,
                flow.dst2src_rst_packets,
                flow.dst2src_fin_packets,
            ]
        ).reshape((1, -1))

        flow.udps.features = np.array(
            [
                # flow.id,
                # flow.expiration_id,
                flow.src_ip,
                flow.src_mac,
                flow.src_oui,
                flow.src_port,
                flow.dst_ip,
                flow.dst_mac,
                flow.dst_oui,
                flow.dst_port,
                flow.protocol,
                flow.ip_version,
                flow.vlan_id,
                flow.bidirectional_first_seen_ms,
                flow.bidirectional_last_seen_ms,
                flow.bidirectional_duration_ms,
                flow.bidirectional_packets,
                flow.bidirectional_bytes,
                flow.src2dst_first_seen_ms,
                flow.src2dst_last_seen_ms,
                flow.src2dst_duration_ms,
                flow.src2dst_packets,
                flow.src2dst_bytes,
                flow.dst2src_first_seen_ms,
                flow.dst2src_last_seen_ms,
                flow.dst2src_duration_ms,
                flow.dst2src_packets,
                flow.dst2src_bytes,
                flow.bidirectional_min_ps,
                flow.bidirectional_mean_ps,
                flow.bidirectional_stddev_ps,
                flow.bidirectional_max_ps,
                flow.src2dst_min_ps,
                flow.src2dst_mean_ps,
                flow.src2dst_stddev_ps,
                flow.src2dst_max_ps,
                flow.dst2src_min_ps,
                flow.dst2src_mean_ps,
                flow.dst2src_stddev_ps,
                flow.dst2src_max_ps,
                flow.bidirectional_min_piat_ms,
                flow.bidirectional_mean_piat_ms,
                flow.bidirectional_stddev_piat_ms,
                flow.bidirectional_max_piat_ms,
                flow.src2dst_min_piat_ms,
                flow.src2dst_mean_piat_ms,
                flow.src2dst_stddev_piat_ms,
                flow.src2dst_max_piat_ms,
                flow.dst2src_min_piat_ms,
                flow.dst2src_mean_piat_ms,
                flow.dst2src_stddev_piat_ms,
                flow.dst2src_max_piat_ms,
                flow.bidirectional_syn_packets,
                flow.bidirectional_cwr_packets,
                flow.bidirectional_ece_packets,
                flow.bidirectional_urg_packets,
                flow.bidirectional_ack_packets,
                flow.bidirectional_psh_packets,
                flow.bidirectional_rst_packets,
                flow.bidirectional_fin_packets,
                flow.src2dst_syn_packets,
                flow.src2dst_cwr_packets,
                flow.src2dst_ece_packets,
                flow.src2dst_urg_packets,
                flow.src2dst_ack_packets,
                flow.src2dst_psh_packets,
                flow.src2dst_rst_packets,
                flow.src2dst_fin_packets,
                flow.dst2src_syn_packets,
                flow.dst2src_cwr_packets,
                flow.dst2src_ece_packets,
                flow.dst2src_urg_packets,
                flow.dst2src_ack_packets,
                flow.dst2src_psh_packets,
                flow.dst2src_rst_packets,
                flow.dst2src_fin_packets,
            ]
        )

        # Normalize the values.
        to_predict_normalized = self.scaler.transform(X=to_predict)

        # Classify.
        flow.udps.prediction = self.model.predict(to_predict_normalized)[0]


class IDS(object):
    def __init__(self, connection):

        # Keep track of the connection to the switch so that we can send it messages.
        self.connection = connection
        # Bind our event listeners to the switch.
        self.connection.addListeners(self)

        # This table maps (switch,MAC-addr) pairs to the port on 'switch' at
        # which we last saw a packet *from* 'MAC-addr'.
        # (In this case, we use a Connection object for the switch.)
        self.table = {}

        self.evaluation_features = []
        self.predictions = []
        self.model_name = "no_eval_single_class_traffic"
        self.analyzed_flows = {
            "benign": 0,
            "dos": 0,
        }

        self.ids_thread = threading.Thread(target=self.ids)
        self.ids_thread.start()
        log.info("IDS started ...")

    def _handle_ConnectionDown(self, event):
        output_dir = "/home/suraj/intrusion-and-vulnerability-detection-in-sdn/results/"
        timestamp = pd.Timestamp.now().strftime("%Y-%m-%d_%H-%M-%S")
        log.info(f"Saving results to {output_dir} ...")
        pd.DataFrame(self.evaluation_features).to_csv(
            output_dir + f"evaluation_features_{self.model_name}_{timestamp}.csv",
            index=False,
            header=False,
        )
        pd.DataFrame(self.predictions).to_csv(
            output_dir + f"predictions_{self.model_name}_{timestamp}.csv",
            index=False,
            header=False,
        )

        log.info(f"Total flows analyzed: {sum(self.analyzed_flows.values())}.")
        log.info(f"{self.analyzed_flows}")

    def ids(self):
        # Load the trained model.
        root_path = "/home/suraj/intrusion-and-vulnerability-detection-in-sdn/ml/saved/"
        # Classifier.
        clf = pickle.load(open(root_path + f"/{self.model_name}_model.pkl", "rb"))
        # Scaler.
        scaler = pickle.load(open(root_path + f"/{self.model_name}_scaler.pkl", "rb"))

        flow_streamer = NFStreamer(
            source="s1-eth1",
            decode_tunnels=False,  # Disable GTP/CAPWAP/TZSP tunnels decoding.
            bpf_filter=None,
            promiscuous_mode=True,  # Enable promiscuous capture mode.
            snapshot_length=1536,  # Control packet slicing size (truncation) in bytes.
            idle_timeout=120,  # Flows that are idle (no packets received) for more than 120 seconds are expired.
            active_timeout=5,  # Flows that are active for more than <active_timeout> seconds are expired.
            accounting_mode=3,  # Accounting mode that will be used to report bytes related features, 3: payload.
            udps=ModelPrediction(model=clf, scaler=scaler),
            n_dissections=0,  # Disable L7 visibility feature.
            statistical_analysis=True,  # Enable post-mortem flow statistical analysis.
            splt_analysis=0,
            n_meters=0,
            max_nflows=0,
            performance_report=0,
            system_visibility_mode=0,
            system_visibility_poll_ms=100,
        )
        class_labels = ["benign", "dos"]

        for flow in flow_streamer:
            prediction = flow.udps.prediction

            self.predictions.append(class_labels[prediction])
            self.evaluation_features.append(flow.udps.features)
            self.analyzed_flows[class_labels[prediction]] += 1

            log.info(
                f"Flow {sum(self.analyzed_flows.values())}. Prediction: {class_labels[prediction]}."
            )

    # Handle messages the switch has sent us because it has no matching rule.
    def _handle_PacketIn(self, event):
        packet = event.parsed

        # Learn the source
        self.table[(event.connection, packet.src)] = event.port

        dst_port = self.table.get((event.connection, packet.dst))

        if dst_port is None:
            # We don't know where the destination is yet. So, we'll just
            # send the packet out all ports (except the one it came in on!)
            # and hope the destination is out there somewhere. :)
            msg = of.ofp_packet_out(data=event.ofp)
            msg.actions.append(of.ofp_action_output(port=of.OFPP_FLOOD))
            self.connection.send(msg)
        else:
            # Since we know the switch ports for both the source and dest
            # MACs, we can install rules for both directions.
            msg = of.ofp_flow_mod()
            msg.match.dl_dst = packet.src
            msg.match.dl_src = packet.dst
            msg.actions.append(of.ofp_action_output(port=event.port))
            self.connection.send(msg)

            # This is the packet that just came in -- we want to
            # install the rule and also resend the packet.
            msg = of.ofp_flow_mod()
            msg.data = event.ofp  # Forward the incoming packet
            msg.match.dl_src = packet.src
            msg.match.dl_dst = packet.dst
            msg.actions.append(of.ofp_action_output(port=dst_port))
            self.connection.send(msg)

            log.debug("Installing %s <-> %s" % (packet.src, packet.dst))


def launch():
    # Logger configuration.
    pox.log.color.launch()
    pox.log.launch(
        format="[@@@bold%(levelname)s@@@reset][@@@bold%(asctime)s@@@reset][@@@bold%(filename)s@@@reset]: @@@bold%(message)s@@@normal"
    )

    def start_switch_connection(event):
        log.info("Controlling %s" % (event.connection,))
        IDS(event.connection)

    # Start connection of the controller with the switch.
    core.openflow.addListenerByName("ConnectionUp", start_switch_connection)
