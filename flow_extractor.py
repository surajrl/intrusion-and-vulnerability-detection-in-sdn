from nfstream import NFStreamer
import time
import fcntl
import argparse
import csv

HEADER = [
    "id",
    "expiration_id",
    "src_ip",
    "src_mac",
    "src_oui",
    "src_port",
    "dst_ip",
    "dst_mac",
    "dst_oui",
    "dst_port",
    "protocol",
    "ip_version",
    "vlan_id",
    "bidirectional_first_seen_ms",
    "bidirectional_last_seen_ms",
    "bidirectional_duration_ms",
    "bidirectional_packets",
    "bidirectional_bytes",
    "src2dst_first_seen_ms",
    "src2dst_last_seen_ms",
    "src2dst_duration_ms",
    "src2dst_packets",
    "src2dst_bytes",
    "dst2src_first_seen_ms",
    "dst2src_last_seen_ms",
    "dst2src_duration_ms",
    "dst2src_packets",
    "dst2src_bytes",
    "bidirectional_min_ps",
    "bidirectional_mean_ps",
    "bidirectional_stddev_ps",
    "bidirectional_max_ps",
    "src2dst_min_ps",
    "src2dst_mean_ps",
    "src2dst_stddev_ps",
    "src2dst_max_ps",
    "dst2src_min_ps",
    "dst2src_mean_ps",
    "dst2src_stddev_ps",
    "dst2src_max_ps",
    "bidirectional_min_piat_ms",
    "bidirectional_mean_piat_ms",
    "bidirectional_stddev_piat_ms",
    "bidirectional_max_piat_ms",
    "src2dst_min_piat_ms",
    "src2dst_mean_piat_ms",
    "src2dst_stddev_piat_ms",
    "src2dst_max_piat_ms",
    "dst2src_min_piat_ms",
    "dst2src_mean_piat_ms",
    "dst2src_stddev_piat_ms",
    "dst2src_max_piat_ms",
    "bidirectional_syn_packets",
    "bidirectional_cwr_packets",
    "bidirectional_ece_packets",
    "bidirectional_urg_packets",
    "bidirectional_ack_packets",
    "bidirectional_psh_packets",
    "bidirectional_rst_packets",
    "bidirectional_fin_packets",
    "src2dst_syn_packets",
    "src2dst_cwr_packets",
    "src2dst_ece_packets",
    "src2dst_urg_packets",
    "src2dst_ack_packets",
    "src2dst_psh_packets",
    "src2dst_rst_packets",
    "src2dst_fin_packets",
    "dst2src_syn_packets",
    "dst2src_cwr_packets",
    "dst2src_ece_packets",
    "dst2src_urg_packets",
    "dst2src_ack_packets",
    "dst2src_psh_packets",
    "dst2src_rst_packets",
    "dst2src_fin_packets",
]


def run(interface, output_filename):
    print(f"Extracting flows from network interface: {interface}")

    my_streamer = NFStreamer(
        source=interface,
        decode_tunnels=False,  # Disable GTP/CAPWAP/TZSP tunnels decoding.
        bpf_filter=None,
        promiscuous_mode=True,  # Enable promiscuous capture mode.
        snapshot_length=1536,  # Control packet slicing size (truncation) in bytes.
        idle_timeout=120,  # Flows that are idle (no packets received) for more than 120 seconds are expired.
        active_timeout=5,  # Flows that are active for more than 5 seconds are expired.
        accounting_mode=3,  # Accounting mode that will be used to report bytes related features, 3: payload.
        udps=None,
        n_dissections=0,  # Disable L7 visibility feature.
        statistical_analysis=True,  # Enable post-mortem flow statistical analysis.
        splt_analysis=0,
        n_meters=0,
        max_nflows=0,
        performance_report=0,
        system_visibility_mode=0,
        system_visibility_poll_ms=100,
    )

    output_filepath = f"/home/suraj/intrusion-and-vulnerability-detection-in-sdn/{output_filename}.csv"
    flows_extracted_count = 0
    flows_and_features = []

    try:
        for flow in my_streamer:
            flows_extracted_count += 1
            flows_and_features.append(flow.values())

            print(f"Flow {flows_extracted_count} extracted")
    except KeyboardInterrupt:
        pass
    finally:
        print(f"Total flows extracted: {flows_extracted_count}")
        # Save the flows and their features into a CSV file.

        with open(output_filepath, "w", newline="") as f:
            csv_writer = csv.writer(f)
            csv_writer.writerow(HEADER)  # Add the header row.
            csv_writer.writerows(
                flows_and_features
            )  # Add the flows and their features.
        print(f"Flows and features saved to: {output_filepath}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-i", "--interface", type=str, help="Specify the network interface."
    )
    parser.add_argument(
        "-o", "--output_filename", type=str, help="Specify the output filename."
    )
    args = parser.parse_args()

    if not args.interface:
        print("Please provide a network interface using the -i or --interface option.")
        exit()
    if not args.output_filename:
        print(
            "Please provide the output filename using the -o or --output_filename option."
        )
        exit()

    run(args.interface, args.output_filename)
