from nfstream import NFStreamer, NFPlugin
import numpy as np
import pickle
import pandas as pd
import argparse


class ModelPrediction(NFPlugin):
    def on_init(self, packet, flow):
        flow.udps.model_prediction = 0
        flow.udps.features = np.empty(shape=(0,))

    def on_expire(self, flow):
        # You can do the same in on_update entrypoint and force expiration with custom id.
        to_predict = np.array(
            [
                flow.bidirectional_duration_ms,
                flow.bidirectional_packets,
                flow.bidirectional_bytes,
                flow.src2dst_duration_ms,
                flow.src2dst_packets,
                flow.src2dst_bytes,
                flow.dst2src_duration_ms,
                flow.dst2src_packets,
                flow.dst2src_bytes,
                flow.bidirectional_min_ps,
                flow.bidirectional_mean_ps,
                flow.bidirectional_stddev_ps,
                flow.bidirectional_max_ps,
                flow.src2dst_min_ps,
                flow.src2dst_mean_ps,
                flow.src2dst_stddev_ps,
                flow.src2dst_max_ps,
                flow.dst2src_min_ps,
                flow.dst2src_mean_ps,
                flow.dst2src_stddev_ps,
                flow.dst2src_max_ps,
                flow.bidirectional_min_piat_ms,
                flow.bidirectional_mean_piat_ms,
                flow.bidirectional_stddev_piat_ms,
                flow.bidirectional_max_piat_ms,
                flow.src2dst_min_piat_ms,
                flow.src2dst_mean_piat_ms,
                flow.src2dst_stddev_piat_ms,
                flow.src2dst_max_piat_ms,
                flow.dst2src_min_piat_ms,
                flow.dst2src_mean_piat_ms,
                flow.dst2src_stddev_piat_ms,
                flow.dst2src_max_piat_ms,
                flow.bidirectional_syn_packets,
                flow.bidirectional_cwr_packets,
                flow.bidirectional_ece_packets,
                flow.bidirectional_urg_packets,
                flow.bidirectional_ack_packets,
                flow.bidirectional_psh_packets,
                flow.bidirectional_rst_packets,
                flow.bidirectional_fin_packets,
                flow.src2dst_syn_packets,
                flow.src2dst_cwr_packets,
                flow.src2dst_ece_packets,
                flow.src2dst_urg_packets,
                flow.src2dst_ack_packets,
                flow.src2dst_psh_packets,
                flow.src2dst_rst_packets,
                flow.src2dst_fin_packets,
                flow.dst2src_syn_packets,
                flow.dst2src_cwr_packets,
                flow.dst2src_ece_packets,
                flow.dst2src_urg_packets,
                flow.dst2src_ack_packets,
                flow.dst2src_psh_packets,
                flow.dst2src_rst_packets,
                flow.dst2src_fin_packets,
            ]
        ).reshape((1, -1))

        flow.udps.features = np.array(
            [
                # flow.id,
                # flow.expiration_id,
                flow.src_ip,
                flow.src_mac,
                flow.src_oui,
                flow.src_port,
                flow.dst_ip,
                flow.dst_mac,
                flow.dst_oui,
                flow.dst_port,
                flow.protocol,
                flow.ip_version,
                flow.vlan_id,
                flow.bidirectional_first_seen_ms,
                flow.bidirectional_last_seen_ms,
                flow.bidirectional_duration_ms,
                flow.bidirectional_packets,
                flow.bidirectional_bytes,
                flow.src2dst_first_seen_ms,
                flow.src2dst_last_seen_ms,
                flow.src2dst_duration_ms,
                flow.src2dst_packets,
                flow.src2dst_bytes,
                flow.dst2src_first_seen_ms,
                flow.dst2src_last_seen_ms,
                flow.dst2src_duration_ms,
                flow.dst2src_packets,
                flow.dst2src_bytes,
                flow.bidirectional_min_ps,
                flow.bidirectional_mean_ps,
                flow.bidirectional_stddev_ps,
                flow.bidirectional_max_ps,
                flow.src2dst_min_ps,
                flow.src2dst_mean_ps,
                flow.src2dst_stddev_ps,
                flow.src2dst_max_ps,
                flow.dst2src_min_ps,
                flow.dst2src_mean_ps,
                flow.dst2src_stddev_ps,
                flow.dst2src_max_ps,
                flow.bidirectional_min_piat_ms,
                flow.bidirectional_mean_piat_ms,
                flow.bidirectional_stddev_piat_ms,
                flow.bidirectional_max_piat_ms,
                flow.src2dst_min_piat_ms,
                flow.src2dst_mean_piat_ms,
                flow.src2dst_stddev_piat_ms,
                flow.src2dst_max_piat_ms,
                flow.dst2src_min_piat_ms,
                flow.dst2src_mean_piat_ms,
                flow.dst2src_stddev_piat_ms,
                flow.dst2src_max_piat_ms,
                flow.bidirectional_syn_packets,
                flow.bidirectional_cwr_packets,
                flow.bidirectional_ece_packets,
                flow.bidirectional_urg_packets,
                flow.bidirectional_ack_packets,
                flow.bidirectional_psh_packets,
                flow.bidirectional_rst_packets,
                flow.bidirectional_fin_packets,
                flow.src2dst_syn_packets,
                flow.src2dst_cwr_packets,
                flow.src2dst_ece_packets,
                flow.src2dst_urg_packets,
                flow.src2dst_ack_packets,
                flow.src2dst_psh_packets,
                flow.src2dst_rst_packets,
                flow.src2dst_fin_packets,
                flow.dst2src_syn_packets,
                flow.dst2src_cwr_packets,
                flow.dst2src_ece_packets,
                flow.dst2src_urg_packets,
                flow.dst2src_ack_packets,
                flow.dst2src_psh_packets,
                flow.dst2src_rst_packets,
                flow.dst2src_fin_packets,
            ]
        )

        # Normalize the values.
        to_predict_normalized = self.scaler.transform(X=to_predict)

        # Classify.
        flow.udps.model_prediction = self.model.predict(to_predict_normalized)[0]


def run(network_interface_name):
    root_path = "/home/suraj/intrusion-and-vulnerability-detection-in-sdn/ml/saved/"
    name = "DoS GoldenEye"
    model_name = "dos_goldeneye"

    # Load the trained classifier.
    clf_filepath = (
        root_path + f"/{model_name}_model.pkl"
    )  # Enter filepath to the trained classifier.
    clf = pickle.load(open(clf_filepath, "rb"))

    # Load the normalization scaler.
    scaler_filepath = (
        root_path + f"/{model_name}_scaler.pkl"
    )  # Enter filepath to the scaler used during the training of the classifier.
    scaler = pickle.load(open(scaler_filepath, "rb"))

    # Load the features that were used for training.
    features_filepath = (
        root_path + "/features.txt"
    )  # Enter filepath to a list with the name of the features used by the classifier.
    with open(features_filepath, "r") as file:
        features = [line.strip() for line in file]

    my_streamer = NFStreamer(
        source=network_interface_name,
        decode_tunnels=False,  # Disable GTP/CAPWAP/TZSP tunnels decoding.
        bpf_filter=None,
        promiscuous_mode=True,  # Enable promiscuous capture mode.
        snapshot_length=1536,  # Control packet slicing size (truncation) in bytes.
        idle_timeout=120,  # Flows that are idle (no packets received) for more than 120 seconds are expired.
        active_timeout=5,  # Flows that are active for more than <active_timeout> seconds are expired.
        accounting_mode=3,  # Accounting mode that will be used to report bytes related features, 3: payload.
        udps=ModelPrediction(model=clf, scaler=scaler),
        n_dissections=0,  # Disable L7 visibility feature.
        statistical_analysis=True,  # Enable post-mortem flow statistical analysis.
        splt_analysis=0,
        n_meters=0,
        max_nflows=0,
        performance_report=0,
        system_visibility_mode=0,
        system_visibility_poll_ms=100,
    )

    print(f"ML classification model: {name}")
    print(f"Analyzing flows on network interface {network_interface_name} ...")
    print()

    features = []
    predictions = []
    class_labels = ["Benign", f"{name}"]
    analyzed_flows = {
        "Benign": 0,
        f"{name}": 0,
    }

    try:
        for flow in my_streamer:
            prediction = flow.udps.model_prediction

            predictions.append(class_labels[prediction])
            features.append(flow.udps.features)

            analyzed_flows[class_labels[prediction]] += 1
            print(
                f"Flow {sum(analyzed_flows.values())}. Prediction: {class_labels[prediction]}."
            )
    finally:
        pd.DataFrame(features).to_csv(
            f"live_features_{model_name}.csv", index=False, header=False
        )
        pd.DataFrame(predictions).to_csv(
            f"live_predictions_{model_name}.csv", index=False, header=False
        )
        print()
        print(f"Total flows analyzed: {sum(analyzed_flows.values())}.")
        print(f"{analyzed_flows}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-i", "--interface", type=str, help="Specify the network interface."
    )
    args = parser.parse_args()

    if not args.interface:
        print("Please provide a network interface using the -i or --interface option.")
        exit()

    run(args.interface)
